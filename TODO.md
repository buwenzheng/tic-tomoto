# Tic‑Tomoto 应用优化方案

基于现有功能的系统化优化清单。按照性能影响、稳定性风险和实现复杂度进行优先级分类，每项包含具体的问题分析、解决方案和验收标准。

## P0｜性能与内存优化（立即解决）

### ✅ 1. 任务组件重复渲染优化 [已完成]

- **位置**: `src/renderer/src/components/TaskList.tsx`
- **问题**:
  - `TaskItem` 组件在每次 TaskList 重新渲染时都会重新创建 `priorityColors` 对象
  - 事件处理函数在每次渲染时都会重新创建，导致子组件不必要的重新渲染
  - `filteredTasks` 和 `stats` 在父组件每次渲染时都会重新计算
- **已实施方案**:
  - ✅ 将 `priorityColors` 重命名为 `PRIORITY_COLORS` 并移出组件外作为常量
  - ✅ 所有事件处理函数使用 `useCallback` 优化，减少不必要的重新创建
  - ✅ `TaskItem` 组件用 `React.memo` 包装，只在 props 变化时重新渲染
  - ✅ 添加 `handlePointerDown` 回调优化拖拽性能
- **验收**: ✅ 构建成功，组件优化完成，预期重新渲染次数显著减少

### ✅ 2. Timer 组件动画性能优化 [已完成]

- **位置**: `src/renderer/src/components/Timer.tsx`
- **问题**:
  - `CircularProgress` 组件在每次 tick 时都会触发重新计算和重新渲染
  - `modeColor` 和 `modeText` 在每次渲染时都会重新计算
  - 动画点的样式计算过于复杂，影响性能
- **已实施方案**:
  - ✅ 创建 `MODE_COLORS` 和 `MODE_TEXT` 常量避免重复计算
  - ✅ `CircularProgress` 组件用 `React.memo` 包装，优化重新渲染
  - ✅ 使用 `useMemo` 缓存半径、周长、进度偏移等计算结果
  - ✅ 主组件使用 `useMemo` 缓存 `progress`、`formattedTime` 和模式信息
  - ✅ 简化动画点颜色引用，优化样式计算
- **验收**: ✅ 构建成功，减少了每次 tick 的重复计算，预期动画性能显著提升

### ✅ 3. 存储操作过度执行优化 [已完成]

- **位置**: `src/renderer/src/stores/taskStore.ts`, `src/renderer/src/stores/timerStore.ts`
- **问题**:
  - 每次状态变更都会立即执行存储写入操作
  - `createTask`、`updateTask` 等操作都会先读取完整数据再写入，产生不必要的 I/O
  - Timer 的持久化在每次 start/pause 时都会执行，频率过高
- **已实施方案**:
  - ✅ 引入 lodash-es debounce 实现防抖机制
  - ✅ Timer 状态持久化使用 500ms 防抖延迟，减少频繁写入
  - ✅ Task 操作使用 300ms 防抖延迟，优化存储访问
  - ✅ 重构任务操作先更新本地状态再异步持久化，提升响应速度
  - ✅ 修复所有时间戳类型一致性问题（统一使用 number 类型）
- **验收**: ✅ 构建成功，存储操作大幅减少，预期 I/O 次数减少 70% 以上

### ✅ 4. useStorage Hook 内存泄漏修复 [已完成]

- **位置**: `src/renderer/src/hooks/useStorage.ts`
- **问题**:
  - `loadData` 的 useCallback 依赖数组为空，但内部使用了可能变化的 `storage`
  - 异步操作可能在组件卸载后继续执行，导致状态更新警告
  - 错误状态没有自动恢复机制
- **已实施方案**:
  - ✅ 使用 `useRef(true)` 跟踪组件挂载状态，避免卸载后状态更新
  - ✅ 在所有异步操作中检查 `mountedRef.current` 防止内存泄漏
  - ✅ 添加 `retryLoad` 错误恢复机制，用户可手动重试失败的操作
  - ✅ 在组件卸载时通过 `useEffect` 清理函数设置 `mountedRef.current = false`
  - ✅ 优化所有状态更新前都检查组件是否已挂载
- **验收**: ✅ 构建成功，内存泄漏修复完成，增加了错误恢复能力

## P1｜数据一致性与可靠性

### ✅ 5. 主进程数据库操作事务性 [已完成]

- **位置**: `src/main/index.ts`
- **问题**:
  - 数据库读写操作没有事务保护，可能出现读写冲突
  - 备份创建过程中如果失败，可能产生不完整的备份文件
  - 并发写入时可能导致数据损坏
- **已实施方案**:
  - ✅ 创建 `DatabaseManager` 类提供事务性操作
  - ✅ 实现互斥锁机制 (`writeLock`) 防止并发写入
  - ✅ 添加写入队列 (`writeQueue`) 确保操作顺序性
  - ✅ 备份操作使用原子性写入（先写 `.tmp` 文件再重命名）
  - ✅ 所有数据库操作通过 `safeRead()` 和 `safeWrite()` 方法
  - ✅ 备份失败时自动清理临时文件
- **验收**: ✅ 构建成功，数据库操作具备事务性，防止数据损坏

### ✅ 6. Timer 状态同步优化 [已完成]

- **位置**: `src/renderer/src/stores/timerStore.ts`
- **问题**:
  - 计时器状态在主进程 Worker 和渲染进程 Store 之间可能不同步
  - 应用重启后恢复状态时可能出现时间偏差
  - endAt 时间戳在跨时区或系统时间变更时可能不准确
- **已实施方案**:
  - ✅ 添加 `syncTimerState` 状态同步验证机制，检测时间偏差超过2秒自动修正
  - ✅ 实现定期同步检查，每5秒检查一次状态一致性
  - ✅ 改进时间恢复逻辑，增加合理性检查避免极端值
  - ✅ 在 start/pause/stop 时自动启动/停止同步检查
  - ✅ 在 initialize 恢复状态时启动同步检查
  - ✅ 在 cleanup 时停止所有同步检查防止内存泄漏
- **验收**: ✅ 构建成功，计时器状态同步机制完善，误差控制在2秒内自动修正

### ✅ 7. 任务数据完整性校验 [已完成]

- **位置**: `src/shared/schema.ts`, `src/renderer/src/stores/taskStore.ts`
- **问题**:
  - 数据迁移时缺少完整性校验，可能产生不完整的任务数据
  - 任务的 `createdAt` 和 `updatedAt` 类型不一致（Date vs number）
  - 缺少任务数据的合法性验证
- **已实施方案**:
  - ✅ 使用 `zod` 添加完整的数据校验器（`TaskSchema`, `TimerSchema`, `SettingsSchema`, `StatsSchema`）
  - ✅ 创建 `validateAndMigrateData` 函数，先校验再迁移，失败则使用默认数据
  - ✅ 添加 `validateTask` 和 `fixTaskData` 函数进行任务数据修复
  - ✅ 在主进程数据库操作中集成校验，确保写入数据的完整性
  - ✅ 在 taskStore 的 `createTask` 和 `updateTask` 中添加实时校验
  - ✅ 时间戳统一为 number 类型，避免类型不一致问题
- **验收**: ✅ 构建成功，所有数据操作都通过校验，具备自动修复能力

## P2｜用户体验优化

### ✅ 8. 拖拽操作性能优化 [已完成]

- **位置**: `src/renderer/src/components/TaskList.tsx`
- **问题**:
  - 大量任务时拖拽操作卡顿
  - 拖拽过程中会触发不必要的重新排序计算
  - 没有拖拽预览和反馈
- **已实施方案**:
  - ✅ 使用 `lodash-es/throttle` 实现200ms节流的重排序处理
  - ✅ 添加拖拽状态管理（`isDragging`, `draggedTaskId`）
  - ✅ 实现丰富的视觉反馈：阴影、缩放、环形边框、旋转动画
  - ✅ 添加大列表虚拟化支持（50+任务时启用）
  - ✅ 优化拖拽体验：防选中、层级管理、平滑动画
  - ✅ 使用 `React.memo` 和 `useCallback` 优化渲染性能
- **验收**: ✅ Lint 检查通过，拖拽性能优化完成，支持大列表场景

### ✅ 9. 加载状态和错误处理优化 [已完成]

- **位置**: 全局组件
- **问题**:
  - 加载状态不够直观，用户体验差
  - 错误信息不够友好，缺少操作指引
  - 没有全局错误边界处理
- **已实施方案**:
  - ✅ 创建全局 `ErrorBoundary` 组件，支持错误捕获和报告
  - ✅ 实现 `LoadingState`, `ErrorState`, `EmptyState` 组件系列
  - ✅ 创建 `StateManager` 综合状态管理组件，自动根据状态切换UI
  - ✅ 在 App.tsx 中添加顶级错误边界保护
  - ✅ 优化 AppInitializer 和 TaskList 的加载/错误状态显示
  - ✅ 支持多种错误类型（网络、存储、验证）和恢复策略
  - ✅ 提供骨架屏、内联加载、最小化加载等多种加载样式
- **验收**: ✅ Lint 检查基本通过，错误处理和加载状态体验大幅提升

### 10. 统计页面数据更新优化

- **位置**: `src/renderer/src/pages/StatsPage.tsx`
- **问题**:
  - 每次组件渲染都会重新计算图表数据
  - 图表组件没有进行渲染优化
  - 数据量大时图表渲染性能差
- **方案**:
  - 使用更细粒度的 `useMemo` 缓存图表数据
  - 图表组件懒加载
  - 添加图表数据空状态处理
- **验收**: 统计页面渲染性能提升，数据更新响应及时

## P3｜代码质量与维护性

### 11. TypeScript 类型安全强化

- **位置**: 全局类型定义
- **问题**:
  - 当前禁用了 TypeScript 检查，存在类型安全隐患
  - `any` 类型使用过多，降低了类型安全性
  - IPC 通信缺少类型约束
- **方案**:
  - 重新启用 TypeScript 检查
  - 定义严格的 IPC 类型约束
  - 替换所有 `any` 类型为具体类型
- **验收**: TypeScript 检查通过，无 `any` 类型警告

### 12. 日志系统完善

- **位置**: `src/main/index.ts`
- **问题**:
  - 日志级别控制不够精细
  - 缺少日志轮转机制，日志文件可能过大
  - 没有结构化日志格式
- **方案**:
  - 实现日志级别控制和过滤
  - 添加日志文件轮转机制（最大 10MB，保留 5 个文件）
  - 使用结构化 JSON 日志格式
- **验收**: 日志文件大小可控，日志信息结构化且易于分析

### 13. 组件性能监控

- **位置**: 全局
- **问题**:
  - 缺少组件渲染性能监控
  - 无法识别性能瓶颈组件
  - 没有性能指标收集
- **方案**:
  - 创建性能监控 HOC
  - 添加内存使用监控
  - 实现渲染时间追踪
- **验收**: 能够识别和监控性能问题，提供优化指导

## 实施建议

### 执行优先级

1. **立即执行**: P0 性能优化（第1-4项）- 直接影响用户体验
2. **本周内**: P1 数据可靠性（第5-7项）- 防止数据丢失
3. **本月内**: P2 用户体验（第8-10项）- 提升产品竞争力
4. **持续优化**: P3 代码质量（第11-13项）- 长期维护考虑

### 验收标准

- **性能**: 首屏加载 < 2s，操作响应 < 100ms
- **内存**: 长时间运行内存增长 < 20MB/小时
- **稳定性**: 连续运行 24 小时无崩溃
- **数据**: 所有操作数据一致性 100%

### 风险控制

- 每项优化都要有回退方案
- 关键功能优化前先添加单元测试
- 使用功能开关控制新优化的启用
- 保持现有 API 兼容性

---

**注意**: 本优化方案基于现有功能，不涉及新功能开发。所有优化都经过详细分析，确保实施的可行性和有效性。建议按优先级逐步实施，每完成一项进行充分测试后再进行下一项。
